<html>

<head>
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitter Sentiment Analysis</title>
</head>

<body>

<div class="row">
        <div class="col-md-2"></div>
        <div class="col-md-8">
            <div class="page-header center">
                <h1>Twitter Sentiment Analysis</h1>
            </div>

		
				<h2>Overview</h2>
			<p>
				<ul>
					<li>Use the <a href="http://d3js.org/">D3</a> Visualization library to display data about Twitter tweets.</li>
					<li>Extract features from data by bag-of-words model</li>
				 	<li>Performed <a href="http://en.wikipedia.org/wiki/Sentiment_analysis">sentiment analysis</a> on tweets using <a href="http://en.wikipedia.org/wiki/Naive_Bayes_classifier">Naive Bayes</a>, <a href="http://en.wikipedia.org/wiki/Logistic_regression">Logistic Regression</a>, and <a href="http://en.wikipedia.org/wiki/Support_vector_machine">Support Vector Machine</a>. </li>
				Extract features from data and build <a href="http://en.wikipedia.org/wiki/Supervised_learning">supervised learning</a> models to automatically classify tweets as either positive or negative (sentiment). Classifiers we will be examining are <a href="http://en.wikipedia.org/wiki/Naive_Bayes_classifier">Naive Bayes</a>, <a href="http://en.wikipedia.org/wiki/Logistic_regression">Logistic Regression</a>, and <a href="http://en.wikipedia.org/wiki/Support_vector_machine">Support Vector Machine</a>. 
				</ul>
			</p>


			<hr>

			<h2>Data</h2>
			<p>
				<pre>
Data file format has 6 fields:
<ol>
<li>the polarity of the tweet (0 = negative sentiment, 1 = positive sentiment)</li>
<li>the id of the tweet (2087)</li>
<li>the date of the tweet (Sat May 16 23:58:44 UTC 2009)</li>
<li>the query (lyx). If there is no query, then this value is NO_QUERY.</li>
<li>the user that tweeted (robotickilldozr)</li>
<li>the text of the tweet (Lyx is cool)</li></ol></pre>
			</p>


			<hr>

			<h2>Tweet Length Timemap</h2>
			<p>
				<a href="https://rawgit.com/XiaojunMENG/Twitter/master/part1.html">Tweet Length Timemap</a>
			</p>
			
			<hr>

			<h2>Feature Extraction</h2>
			<h3>Bag-of-words model</h3>
			<p>
				<br>
				Below is an example:<br>

				Here are three documents, each document being one tweet.
<pre>
<ol><li>i love you and you love me</li>
<li>you are my love</li>
<li>my love for you</li></ol></pre>
				
				<br>
				Based on these three documents, a <b>vocabulary list</b> is constructed as:
<pre>
<ul><li>'i'</li>
<li>'love'</li>
<li>'you'</li>
<li>'and'</li>
<li>'me'</li>
<li>'are'</li>
<li>'my'</li>
<li>'for'</li></ul></pre>
				which has 8 distinct words. And using the indices of the vocabulary list, each document is represented by an 8-entry vector:
<pre>
<ol><li>[True, True, True, True, True, False, False, False]</li>
<li>[False, True, True, False, False, True, True, False]</li>
<li>[False, True, True, False, False, False, True, True]</li></ol></pre>
where each entry of the vectors refers to the existence of the corresponding entry in the vocabulary list. The first entry is only 'True' for the first tweet since in the vocabulary, 'i' only exists in the first tweet. Usually, if we had a longer document, we would define each entry of vectors to refer to the count of the corresponding entry in the dictionary. For example, the first tweet would be vectorized as <code>[1, 2, 2, 1, 1, 0, 0, 0]</code>. However, since tweet texts are very short (limited to 140 characters), having the boolean entries will suffice for our purpose.<br>
</p>

<h2>Geomapping Tweet Sentiment</h2>
			<p>
				<a href="https://rawgit.com/XiaojunMENG/Twitter/master/part2.html">Geomapping Tweet Sentiment</a>
			</p>

			
        <div class="col-md-2"></div>
    </div>

</body>
</html>
